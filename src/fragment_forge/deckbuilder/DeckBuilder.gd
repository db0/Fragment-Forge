extends DeckBuilder

# The path to the DBFilterButton scene.
const _FILTER_ICON_BUTTON_SCENE_FILE = CFConst.PATH_CUSTOM\
		+ "DeckBuilder/DBFilterIconButton.tscn"
const _FILTER_ICON_BUTTON_SCENE = preload(_FILTER_ICON_BUTTON_SCENE_FILE)

onready var back_button = $VBC/HBC/MC/CurrentDeck/Buttons/Back

func _ready() -> void:
	deck_summaries.connect("persona_selected", self, "_on_persona_selected")

func _process(_delta: float) -> void:
	# We keep updating the card count label with the amount of cards in the deck
	var used_inspiration = 0
	var max_inspiration = deck_summaries.maximum_inspiration
	for category in _deck_cards.get_children():
		for card_object in category.get_node("CategoryCards").get_children():
			var card_properties = cfc.card_definitions[card_object.card_name]
			if card_properties.Type == CardConfig.CardTypes.SHADER:
				used_inspiration += (card_properties.skill_req) * card_object.quantity
			if deck_summaries.affinity != card_properties["_affinity"]:
				var quantity : int = card_object.quantity
				if deck_summaries.persona\
						and deck_summaries.persona.persona_name == "Fractal Thoughts"\
						and card_properties.Type == CardConfig.CardTypes.SHADER:
					quantity -= 1
				max_inspiration -= card_properties.get("_influence",0) * quantity
	deck_summaries.inpiration_label.text =\
			"Inpiration: " + str(used_inspiration) + '/' + str(max_inspiration)
	if max_inspiration < deck_summaries.maximum_inspiration:
		deck_summaries.inpiration_label.text += ' (Starting: ' + str(deck_summaries.maximum_inspiration) + ')'
	if used_inspiration > max_inspiration:
		deck_summaries.inpiration_label.modulate = Color(1,0,0)
	else:
		deck_summaries.inpiration_label.modulate = Color(1,1,1)

# Extend this class and call this function, when your game has a value field
# Which is suposed to be autogenerated in some fashion.
# warning-ignore:unused_argument
func generate_value(property: String, card_properties: Dictionary):
	if property == 'Value':
		return(FFCard.generate_shader_value(
			card_properties.Time,
			card_properties.skill_req,
			card_properties.get("_abilities_power",0)))
	else:
		return('')

func prepate_filter_buttons() -> void:
	var total_unique_values := 0
	for button_property in filter_button_properties:
		var unique_values := CFUtils.get_unique_values(button_property)
		total_unique_values += unique_values.size()
		# We want to avoid exceeding 8 buttons
		if total_unique_values <= 8:
			for value in CFUtils.get_unique_values(button_property):
				# Excluded types, don't have a filter button
				if value in CardConfig.TYPES_TO_HIDE_IN_DECKBUILDER:
					continue
				var filter_button
				if button_property != "_affinity":
					filter_button = _FILTER_BUTTON_SCENE.instance()
					filter_button.setup(button_property, value)
					filter_button.connect("pressed", self, "_on_filter_button_pressed")
				else:
					filter_button = _FILTER_ICON_BUTTON_SCENE.instance()
					filter_button.setup(button_property, value)
					filter_button.connect("filter_toggled", self, "_on_filter_button_pressed")
				_filter_buttons.add_child(filter_button)


# Triggered when the Save button is pressed.
# Stores the deck in JSON format to the folder defined in CFConst.DECKS_PATH
func _on_Save_pressed() -> void:
	var cards_count = 0
	var persona_name
	if deck_summaries.persona:
		persona_name = deck_summaries.persona.persona_name
	var deck_dictionary := {
		"persona": persona_name,
		"name": _deck_name.text,
		"cards": {},
	}
	for category in _deck_cards.get_children():
		for card_object in category.get_node("CategoryCards").get_children():
			deck_dictionary.cards[card_object.card_name] = card_object.quantity
			cards_count += card_object.quantity
	deck_dictionary["total"] = cards_count
	var dir = Directory.new()
	if not dir.dir_exists(CFConst.DECKS_PATH):
		dir.make_dir(CFConst.DECKS_PATH)
	var file = File.new()
	file.open(CFConst.DECKS_PATH + _deck_name.text + '.json', File.WRITE)
	file.store_string(JSON.print(deck_dictionary, '\t'))
	file.close()
	_set_notice("Deck saved")


# Triggered when a deck has been chosen from the Load menu
# Populates the Current Deck Details with the contents of the chosen deck
# as they were stored to disk.
func _on_deck_loaded(deck) -> void:
	# We need to zero all available cards,
	# otherwise previous selections will not be wiped if they're not in the deck
	for list_card_object in _available_cards.get_children():
		list_card_object.quantity = 0
	_deck_name.text = deck.name
	if deck.get("persona"):
		var persona := Persona.new(deck.persona)
		deck_summaries.persona_selected(persona)
	else:
		deck_summaries.reset_persona()
	for card_name in deck.cards:
		# Our Current Deck quantities are always populated via the
		# ListCardObjects. So we need to modify those in order to update the
		# deck itself and connect the objects correctly.
		for list_card_object in _available_cards.get_children():
			if list_card_object.card_name == card_name:
				list_card_object.quantity = deck.cards[card_name]
	_set_notice("Deck loaded")

# Clears deck list
func _on_Reset_pressed() -> void:
	._on_Reset_pressed()
	deck_summaries.reset_persona()

func _on_persona_selected() -> void:
	for card_object in _available_cards.get_children():
		card_object.check_influence()
